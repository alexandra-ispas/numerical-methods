ISPAS ALEXANDRA-PETRINA
   312CD


[M] = Matrice(nume)
Aceasta este o functie construita de mine ce returneaza matricea M corespunzatoare algoritmului dat.
Am folosit dlmread pentru a citi datele de intrare. In vectorul L-am retinut numarul de vecini aferent fiecarui nod si in vectorul v am retinut temporar vecinii unui nod. Pentru fiecare pagina, caut daca aceasta se numara printre vecinii ei. Daca da, scad din numarul de vecini link-ul catre ea insasi. Apoi am construit matricea de adiacenta A unde am pus 1 pe pozitiile in care am legaturi.
Apoi am continuat cu matricea M.
Am initializat-o cu NxN valori de zero, am cautat pozitiile pe care matricea A are valori de 1, iar, pe acela pozitii, in matricea M vor fi valori egale cu 1 / (numarul de vecini ai paginii i). Matricea M trebuie transpusa.


R = Iterative(nume, d, eps)
Prima data am creat matricea M. Apoi il construiesc pe R pe care l-am initializat cu un vector ce are 1 / N pe toate pozitiile. In continuare implemantez algoritmul dat.


[x] = SST(A, b)
Aceasta este o functie ce rezolva un sistem superior triunghiular pe care am implementat-o eu si la laborator.


[Q, R] = GrammSchmidt(A) 
Functia de factorizare QR.


R = Algebraic(nume, d)
Am citit numarul de noduri si am construit matricea M. Am initializat vectorul R ca si la metoda iterativa. Dupa aceea am urmato codul dat.
Dupa ce am gasit vectorul R, pentru a intoarce solutia finala, am rezolvat un sistem superior triunghiular prim initializarea unei maitrici T si factorizarea qr a acesteia folosind algoritmul Gramm Schmidt, initializarea unui vector v ce reprezinta termenii liberi ai sistemului si rezolvarea propriu-zisa a SST-ului.


y = Apartenenta(x, val1, val2)
Din continuitatea functiei date - f(val1) = 0 si f(val2) = 1 -, am gasit formule pentru a si b si am calculat functia in punctul x.

[R1 R2] = PageRank(nume, d, eps)
Am construit R1 SI R2 folosindu-ma de functiile deja implementate. Am gasit valoarea u(PR1(i) si am afisat-o in fisier. In continuare m-am ocupat de fisierul in care voi scrie. 
Pentru a putea sorta indicii valorilor lui RP1 care se regasesc de 2 ori in R2, am folosit un j_prev, initializat fara importanta cu 0. Il caut pe i in R2 si daca vectorul j returnat are mau mult de 1 element, ceea ce inseamna ca avem elemente egale in R2, le pun in ordine inversa, respectiv: adaug mai intai j(2) si dupa aceea j(1)

